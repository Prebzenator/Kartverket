@model WebApplication1.Models.ObstacleData
@using WebApplication1.Models
@using System.Globalization

@{
    @* Set page title and format coordinates *@
    ViewData["Title"] = $"Report #{Model.Id}";
    var lat = Model.Latitude?.ToString("0.######", CultureInfo.InvariantCulture);
    var lng = Model.Longitude?.ToString("0.######", CultureInfo.InvariantCulture);

    var isDraft = Model.IsProbablyDraft;
}

<div class="container py-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1 class="h3 mb-1">Report #@Model.Id</h1>
            <p class="text-muted mb-0">
                Reported by @Model.ReporterName on @Model.ReportedAt.ToString("dd.MM.yyyy HH:mm")
            </p>
        </div>
        <a asp-action="Log" class="btn btn-outline-secondary">
            <i class="bi bi-arrow-left"></i> Back to Organization Reports
        </a>
    </div>

    <!-- Messages -->
    @if (TempData["SuccessMessage"] != null)
    {
        <div class="alert alert-success alert-dismissible fade show">
            @TempData["SuccessMessage"]
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    }
    @if (TempData["ErrorMessage"] != null)
    {
        <div class="alert alert-danger alert-dismissible fade show">
            @TempData["ErrorMessage"]
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    }

    <div class="row g-4">
        <!-- Left Column: Obstacle Details -->
        <div class="col-lg-8">
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-light d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Obstacle Information</h5>
                    @* Show edit button for all own reports (not just drafts) *@
                    @if (ViewBag.CanEdit == true)
                    {
                        <a asp-action="EditReport" asp-route-id="@Model.Id" class="btn btn-sm btn-primary">
                            <i class="bi bi-pencil-square"></i> Edit Report
                        </a>
                    }
                </div>
                <div class="card-body">
                    <dl class="row mb-0">
                        <dt class="col-sm-3">Name</dt>
                        <dd class="col-sm-9">@Model.ObstacleName</dd>

                        <dt class="col-sm-3">Height</dt>
                        <dd class="col-sm-9">@Model.ObstacleHeight?.ToString("0.00") meters</dd>

                        <dt class="col-sm-3">Description</dt>
                        <dd class="col-sm-9">@Model.ObstacleDescription</dd>

                        <dt class="col-sm-3">Latitude</dt>
                        <dd class="col-sm-9">@lat</dd>

                        <dt class="col-sm-3">Longitude</dt>
                        <dd class="col-sm-9">@lng</dd>
                    </dl>
                </div>
            </div>

            <!-- Map Display -->
            @if (Model.Latitude.HasValue && Model.Longitude.HasValue)
            {
                <div class="card shadow-sm">
                    <div class="card-header bg-light">
                        <h5 class="mb-0">Location</h5>
                    </div>
                    <div class="card-body p-0">
                        <div id="map" style="height: 400px;"></div>
                    </div>
                </div>
            }
        </div>

        <!-- Right Column: Status & Reporter Info -->
        <div class="col-lg-4">
            <!-- Current Status -->
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-light">
                    <h5 class="mb-0">Current Status</h5>
                </div>
                <div class="card-body">
                    <div class="mb-3 text-center">
                        @{
                            string badgeClass = "bg-secondary";
                            string statusText = "Draft";
                            string iconClass = "bi-file-earmark";

                            if (isDraft)
                            {
                                // Draft: NotApproved without admin review
                                badgeClass = "bg-secondary";
                                statusText = "Draft - Not Submitted";
                                iconClass = "bi-file-earmark-text";
                            }
                            else
                            {
                                // Not a draft, check actual status
                                switch (Model.Status)
                                {
                                    case ReportStatus.Pending:
                                        badgeClass = "bg-warning text-dark";
                                        statusText = "Pending Review";
                                        iconClass = "bi-clock";
                                        break;
                                    case ReportStatus.Approved:
                                        badgeClass = "bg-success";
                                        statusText = "Approved";
                                        iconClass = "bi-check-circle";
                                        break;
                                    case ReportStatus.NotApproved:
                                        // NotApproved with admin comments = rejected
                                        badgeClass = "bg-danger";
                                        statusText = "Rejected";
                                        iconClass = "bi-x-circle";
                                        break;
                                }
                            }
                        }
                        <h4>
                            <span class="badge @badgeClass w-100 py-2">
                                <i class="bi @iconClass"></i> @statusText
                            </span>
                        </h4>
                    </div>

                    @if (!string.IsNullOrEmpty(Model.ReviewedByName))
                    {
                        <p class="mb-1"><strong>Reviewed by:</strong> @Model.ReviewedByName</p>
                        <p class="text-muted small">@Model.LastReviewedAt?.ToString("dd.MM.yyyy HH:mm")</p>
                    }
                </div>
            </div>

            <!-- Reporter Info -->
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-light">
                    <h5 class="mb-0">Reporter Information</h5>
                </div>
                <div class="card-body">
                    <p class="mb-1"><strong>Name:</strong> @Model.ReporterName</p>
                    <p class="mb-1"><strong>Organization:</strong> @Model.ReporterOrganization</p>
                    <p class="mb-0"><strong>User ID:</strong> <small class="text-muted">@Model.ReportedByUserId</small></p>
                </div>
            </div>

            <!-- Admin Comments Display (only for rejected reports, not drafts) -->
            @if (!isDraft && Model.Status == ReportStatus.NotApproved && !string.IsNullOrEmpty(Model.AdminComments))
            {
                <div class="card shadow-sm border-danger">
                    <div class="card-header bg-danger text-white">
                        <h5 class="mb-0">
                            <i class="bi bi-exclamation-triangle"></i> Rejection Feedback
                        </h5>
                    </div>
                    <div class="card-body">
                        <p class="mb-0">@Model.AdminComments</p>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

    <script>
        (function () {
            const mapEl = document.getElementById('map');
            if (!mapEl) return;

            // Create map with a safe default view
            const map = L.map('map').setView([60.472, 8.4689], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            // Raw GeoJSON from server (use Html.Raw so JSON isn't HTML-encoded)
            const geometry = @Html.Raw(string.IsNullOrEmpty(Model?.GeometryJson) ? "null" : Model.GeometryJson);

            // Helper: extract a first coordinate [lng, lat] from arbitrary GeoJSON
            function findFirstCoord(obj) {
                if (!obj) return null;
                if (obj.type === 'FeatureCollection' && Array.isArray(obj.features)) {
                    for (const f of obj.features) {
                        const c = findFirstCoord(f);
                        if (c) return c;
                    }
                    return null;
                }
                if (obj.type === 'Feature') return findFirstCoord(obj.geometry);
                if (obj.type === 'Point' && Array.isArray(obj.coordinates)) return obj.coordinates;
                if ((obj.type === 'LineString' || obj.type === 'MultiPoint') && Array.isArray(obj.coordinates)) return obj.coordinates[0] || null;
                if (obj.type === 'Polygon' && Array.isArray(obj.coordinates)) return (obj.coordinates[0] && obj.coordinates[0][0]) || null;
                if (obj.type === 'MultiPolygon' && Array.isArray(obj.coordinates)) return (obj.coordinates[0] && obj.coordinates[0][0] && obj.coordinates[0][0][0]) || null;
                if (obj.type === 'GeometryCollection' && Array.isArray(obj.geometries)) {
                    for (const g of obj.geometries) {
                        const c = findFirstCoord(g);
                        if (c) return c;
                    }
                }
                return null;
            }

            // Filter FeatureCollection / Feature / Geometry to polygons/lines; returns null if none found
            function filterPolygonsAndLines(gj) {
                if (!gj) return null;
                if (gj.type === 'FeatureCollection' && Array.isArray(gj.features)) {
                    const features = gj.features.filter(f => {
                        const t = (f && f.geometry && f.geometry.type) || '';
                        return t === 'Polygon' || t === 'MultiPolygon' || t === 'LineString' || t === 'MultiLineString' || t === 'GeometryCollection';
                    });
                    if (!features.length) return null;
                    return { type: 'FeatureCollection', features };
                }
                if (gj.type === 'Feature') {
                    const t = (gj.geometry && gj.geometry.type) || '';
                    if (t === 'Polygon' || t === 'MultiPolygon' || t === 'LineString' || t === 'MultiLineString' || t === 'GeometryCollection') return gj;
                    return null;
                }
                if (gj.type === 'Polygon' || gj.type === 'MultiPolygon' || gj.type === 'LineString' || gj.type === 'MultiLineString' || gj.type === 'GeometryCollection') return gj;
                return null;
            }

            try {
                // Try to render polygons & lines first
                const filtered = filterPolygonsAndLines(geometry);

                if (filtered) {
                    const layer = L.geoJSON(filtered, {
                        pointToLayer: (feature, latlng) => L.marker(latlng),
                        style: function (feature) {
                            const t = feature && feature.geometry && feature.geometry.type;
                            if (t && t.indexOf('Line') === 0) {
                                return { color: '#1f77b4', weight: 3, opacity: 0.9 };
                            }
                            return { color: '#e6550d', weight: 2, fillOpacity: 0.25 };
                        }
                    }).addTo(map);

                    // Fit to bounds if possible
                    const bounds = (typeof layer.getBounds === 'function') ? layer.getBounds() : null;
                    if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
                        map.fitBounds(bounds, { padding: [20, 20] });
                        return;
                    }
                }

                // If we reach here either no polygon/line features were found, or bounds invalid.
                // Try to render a GeoJSON Point (if present) or fallback to model lat/lng.

                if (geometry) {
                    // Attempt to render any Points in the GeoJSON
                    const pointLayer = L.geoJSON(geometry, {
                        pointToLayer: (feature, latlng) => L.marker(latlng)
                    }).addTo(map);

                    const pBounds = (typeof pointLayer.getBounds === 'function') ? pointLayer.getBounds() : null;
                    if (pBounds && typeof pBounds.isValid === 'function' && pBounds.isValid()) {
                        map.fitBounds(pBounds, { padding: [20, 20] });
                        return;
                    }

                    // Otherwise fall back to first coordinate extracted from the GeoJSON
                    const first = findFirstCoord(geometry);
                    if (first && first.length >= 2) {
                        const lng = parseFloat(first[0]);
                        const lat = parseFloat(first[1]);
                        if (!isNaN(lat) && !isNaN(lng)) {
                            L.marker([lat, lng]).addTo(map);
                            map.setView([lat, lng], 14);
                            return;
                        }
                    }
                }

                // Final fallback: use Model.Latitude/Longitude if present
                if (@(Model?.Latitude.HasValue == true ? "true" : "false") && @(Model?.Longitude.HasValue == true ? "true" : "false")) {
                    const lat = parseFloat("@(Model.Latitude?.ToString(CultureInfo.InvariantCulture) ?? "")");
                    const lng = parseFloat("@(Model.Longitude?.ToString(CultureInfo.InvariantCulture) ?? "")");
                    if (!isNaN(lat) && !isNaN(lng)) {
                        L.marker([lat, lng]).addTo(map);
                        map.setView([lat, lng], 14);
                        return;
                    }
                }

                // Nothing to display
                console.warn('No usable geometry or coordinates found for rendering.');
            } catch (err) {
                console.warn('Error rendering map preview', err);
            } finally {
                setTimeout(() => { if (map) map.invalidateSize(); }, 120);
            }
        })();
    </script>
}

