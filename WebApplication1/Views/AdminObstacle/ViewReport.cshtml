@model WebApplication1.Models.ObstacleData
@using WebApplication1.Models
@using System.Globalization

@{
    ViewData["Title"] = $"Report #{Model.Id}";
    var administrators = ViewBag.Administrators as IEnumerable<ApplicationUser>;
    var lat = Model.Latitude?.ToString("0.######", CultureInfo.InvariantCulture);
    var lng = Model.Longitude?.ToString("0.######", CultureInfo.InvariantCulture);
}

<div class="container py-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1 class="h3 mb-1">Report #@Model.Id</h1>
            <p class="text-muted mb-0">
                Reported by @Model.ReporterName on @Model.ReportedAt.ToString("dd.MM.yyyy HH:mm")
            </p>
        </div>
        <a asp-action="Dashboard" class="btn btn-outline-secondary">
            <i class="bi bi-arrow-left"></i> Back to Dashboard
        </a>
    </div>

    <!-- Messages -->
    @if (TempData["SuccessMessage"] != null)
    {
        <div class="alert alert-success alert-dismissible fade show">
            @TempData["SuccessMessage"]
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    }
    @if (TempData["ErrorMessage"] != null)
    {
        <div class="alert alert-danger alert-dismissible fade show">
            @TempData["ErrorMessage"]
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    }

    <div class="row g-4">
        <!-- Left Column: Obstacle Details -->
        <div class="col-lg-8">
            <!-- Edit Obstacle Information -->
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-light">
                    <h5 class="mb-0">Obstacle Information</h5>
                </div>
                <div class="card-body">
                    <form asp-action="UpdateReport" method="post" id="editForm">
                        @Html.AntiForgeryToken()
                        <input type="hidden" name="id" value="@Model.Id" />

                        <div class="mb-3">
                            <label asp-for="ObstacleName" class="form-label"></label>
                            <input asp-for="ObstacleName" class="form-control" />
                        </div>

                        <div class="mb-3">
                            <label asp-for="ObstacleHeight" class="form-label"></label>
                            <input asp-for="ObstacleHeight" type="number" step="0.01" class="form-control" />
                        </div>

                        <div class="mb-3">
                            <label asp-for="ObstacleDescription" class="form-label"></label>
                            <textarea asp-for="ObstacleDescription" class="form-control" rows="4"></textarea>
                        </div>

                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label asp-for="Latitude" class="form-label"></label>
                                <input asp-for="Latitude" class="form-control" />
                            </div>
                            <div class="col-md-6 mb-3">
                                <label asp-for="Longitude" class="form-label"></label>
                                <input asp-for="Longitude" class="form-control" />
                            </div>
                        </div>

                        <button type="submit" class="btn btn-primary">
                            <i class="bi bi-save"></i> Save Changes
                        </button>
                    </form>
                </div>
            </div>

            <!-- Map Display -->
            @if (Model.Latitude.HasValue && Model.Longitude.HasValue)
            {
                <div class="card shadow-sm">
                    <div class="card-header bg-light">
                        <h5 class="mb-0">Location</h5>
                    </div>
                    <div class="card-body p-0">
                        <div id="map" style="height: 400px;"></div>
                    </div>
                </div>
            }
        </div>

        <!-- Right Column: Status & Actions -->
        <div class="col-lg-4">
            <!-- Current Status -->
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-light">
                    <h5 class="mb-0">Current Status</h5>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        @if (Model.IsProbablyDraft)
                        {
                            <h4>
                                <span class="badge bg-secondary w-100 py-2">
                                    <i class="bi bi-file-earmark-text"></i> Draft
                                </span>
                            </h4>
                        }
                        else
                        {
                            switch (Model.Status)
                            {
                                case ReportStatus.Pending:
                                    <h4>
                                        <span class="badge bg-warning text-dark w-100 py-2">
                                            <i class="bi bi-clock"></i> Pending Review
                                        </span>
                                    </h4>
                                    break;
                                case ReportStatus.Approved:
                                    <h4>
                                        <span class="badge bg-success w-100 py-2">
                                            <i class="bi bi-check-circle"></i> Approved
                                        </span>
                                    </h4>
                                    break;
                                case ReportStatus.NotApproved:
                                    <h4>
                                        <span class="badge bg-danger w-100 py-2">
                                            <i class="bi bi-x-circle"></i> Rejected
                                        </span>
                                    </h4>
                                    break;
                            }
                        }
                    </div>

                    @if (!string.IsNullOrEmpty(Model.ReviewedByName))
                    {
                        <p class="mb-1"><strong>Reviewed by:</strong> @Model.ReviewedByName</p>
                        <p class="text-muted small">@Model.LastReviewedAt?.ToString("dd.MM.yyyy HH:mm")</p>
                    }
                </div>
            </div>

            <!-- Change Status Actions -->
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-light">
                    <h5 class="mb-0">Actions</h5>
                </div>
                <div class="card-body">
                    @if (Model.Status != ReportStatus.Approved)
                    {
                        <form asp-action="ApproveReport" method="post" class="mb-2">
                            @Html.AntiForgeryToken()
                            <input type="hidden" name="id" value="@Model.Id" />
                            <button type="submit" class="btn btn-success w-100">
                                <i class="bi bi-check-circle"></i> Approve Report
                            </button>
                        </form>
                    }

                    @if (Model.Status != ReportStatus.NotApproved)
                    {
                        <button type="button" class="btn btn-danger w-100 mb-2"
                                data-bs-toggle="modal" data-bs-target="#rejectModal">
                            <i class="bi bi-x-circle"></i> Reject Report
                        </button>
                    }

                    @if (Model.Status != ReportStatus.Pending)
                    {
                        <form asp-action="SetPending" method="post">
                            @Html.AntiForgeryToken()
                            <input type="hidden" name="id" value="@Model.Id" />
                            <button type="submit" class="btn btn-warning w-100">
                                <i class="bi bi-arrow-counterclockwise"></i> Set to Pending
                            </button>
                        </form>
                    }
                </div>
            </div>

            <!-- Assignment -->
            <div class="card shadow-sm mb-4">
                <div class="card-header bg-light">
                    <h5 class="mb-0">Assignment</h5>
                </div>
                <div class="card-body">
                    <form asp-action="AssignReport" method="post">
                        @Html.AntiForgeryToken()
                        <input type="hidden" name="id" value="@Model.Id" />

                        <div class="mb-3">
                            @* FIXED: Use "Registry Administrator" instead of just "Administrator" *@
                            <label class="form-label">Assign to Registry Administrator</label>
                            <select name="assignToUserId" class="form-select">
                                <option value="">Unassigned</option>
                                @foreach (var admin in administrators)
                                {
                                    <option value="@admin.Id" selected="@(admin.Id == Model.AssignedToUserId)">
                                        @(admin.FullName ?? admin.Email)
                                    </option>
                                }
                            </select>
                        </div>

                        <button type="submit" class="btn btn-primary w-100">
                            <i class="bi bi-person-check"></i> Update Assignment
                        </button>
                    </form>
                </div>
            </div>

            <!-- Reporter Info -->
            <div class="card shadow-sm">
                <div class="card-header bg-light">
                    <h5 class="mb-0">Reporter Information</h5>
                </div>
                <div class="card-body">
                    <p class="mb-1"><strong>Name:</strong> @Model.ReporterName</p>
                    <p class="mb-1"><strong>Organization:</strong> @Model.ReporterOrganization</p>
                    <p class="mb-0"><strong>User ID:</strong> <small class="text-muted">@Model.ReportedByUserId</small></p>
                </div>
            </div>

            <!-- Admin Comments Display -->
            @if (!string.IsNullOrEmpty(Model.AdminComments))
            {
                <div class="card shadow-sm mt-4 border-danger">
                    <div class="card-header bg-danger text-white">
                        <h5 class="mb-0">Rejection Feedback</h5>
                    </div>
                    <div class="card-body">
                        <p class="mb-0">@Model.AdminComments</p>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

<!-- Reject Modal -->
<div class="modal fade" id="rejectModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <form asp-action="RejectReport" method="post">
                @Html.AntiForgeryToken()
                <input type="hidden" name="id" value="@Model.Id" />

                <div class="modal-header">
                    <h5 class="modal-title">Reject Report</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i>
                        Comments are <strong>required</strong> when rejecting a report.
                    </div>
                    <div class="mb-3">
                        <label for="adminComments" class="form-label">Reason for Rejection *</label>
                        <textarea name="adminComments" id="adminComments"
                                  class="form-control" rows="4" required
                                  placeholder="Explain why this report is being rejected..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="submit" class="btn btn-danger">
                        <i class="bi bi-x-circle"></i> Reject Report
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>
@section Scripts {
    @if (!string.IsNullOrEmpty(Model?.GeometryJson) || (Model?.Latitude.HasValue == true && Model?.Longitude.HasValue == true))
    {
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>

        <script>
            (function () {
                const mapEl = document.getElementById('map');
                if (!mapEl) { console.warn('No map container found'); return; }

                // Safe parse of model coordinates
                const latStr = "@(Model?.Latitude.HasValue == true ? Model.Latitude.Value.ToString("0.######", System.Globalization.CultureInfo.InvariantCulture) : "")";
                const lngStr = "@(Model?.Longitude.HasValue == true ? Model.Longitude.Value.ToString("0.######", System.Globalization.CultureInfo.InvariantCulture) : "")";
                const latModel = latStr ? parseFloat(latStr) : NaN;
                const lngModel = lngStr ? parseFloat(lngStr) : NaN;

                const map = L.map('map').setView([(!isNaN(latModel) ? latModel : 60.472), (!isNaN(lngModel) ? lngModel : 8.4689)], (!isNaN(latModel) && !isNaN(lngModel)) ? 14 : 5);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; OpenStreetMap contributors'
                }).addTo(map);

                // Raw GeoJSON from model
                const geometry = @Html.Raw(string.IsNullOrEmpty(Model?.GeometryJson) ? "null" : Model.GeometryJson);

                // Helper: extract first usable coordinate [lng, lat] from GeoJSON
                function findFirstCoord(obj) {
                    if (!obj) return null;
                    if (obj.type === 'FeatureCollection' && Array.isArray(obj.features)) {
                        for (const f of obj.features) {
                            const c = findFirstCoord(f);
                            if (c) return c;
                        }
                        return null;
                    }
                    if (obj.type === 'Feature') return findFirstCoord(obj.geometry);
                    if (obj.type === 'Point' && Array.isArray(obj.coordinates)) return obj.coordinates;
                    if ((obj.type === 'LineString' || obj.type === 'MultiPoint') && Array.isArray(obj.coordinates)) return obj.coordinates[0] || null;
                    if (obj.type === 'Polygon' && Array.isArray(obj.coordinates)) return (obj.coordinates[0] && obj.coordinates[0][0]) || null;
                    if (obj.type === 'MultiPolygon' && Array.isArray(obj.coordinates)) return (obj.coordinates[0] && obj.coordinates[0][0] && obj.coordinates[0][0][0]) || null;
                    if (obj.type === 'GeometryCollection' && Array.isArray(obj.geometries)) {
                        for (const g of obj.geometries) {
                            const c = findFirstCoord(g);
                            if (c) return c;
                        }
                    }
                    return null;
                }

                // Filter to polygons/lines only (used for area/line rendering)
                function filterPolygonsAndLines(gj) {
                    if (!gj) return null;
                    if (gj.type === 'FeatureCollection' && Array.isArray(gj.features)) {
                        const features = gj.features.filter(f => {
                            const t = (f && f.geometry && f.geometry.type) || '';
                            return t === 'Polygon' || t === 'MultiPolygon' || t === 'LineString' || t === 'MultiLineString';
                        });
                        if (!features.length) return null;
                        return { type: 'FeatureCollection', features };
                    }
                    if (gj.type === 'Feature') {
                        const t = (gj.geometry && gj.geometry.type) || '';
                        if (t === 'Polygon' || t === 'MultiPolygon' || t === 'LineString' || t === 'MultiLineString') return gj;
                        return null;
                    }
                    if (gj.type === 'Polygon' || gj.type === 'MultiPolygon' || gj.type === 'LineString' || gj.type === 'MultiLineString') return gj;
                    return null;
                }

                // Utility: update input fields with lat/lng (6 decimals)
                function setInputs(lat, lng) {
                    const latEl = document.getElementById('Latitude');
                    const lngEl = document.getElementById('Longitude');
                    if (latEl) latEl.value = lat.toFixed(6);
                    if (lngEl) lngEl.value = lng.toFixed(6);
                }

                // Add polygon/line layers first
                try {
                    if (geometry) {
                        const filtered = filterPolygonsAndLines(geometry);
                        if (filtered) {
                            const layer = L.geoJSON(filtered, {
                                style: function (feature) {
                                    const t = feature && feature.geometry && feature.geometry.type;
                                    if (t && t.indexOf('Line') === 0) return { color: '#1f77b4', weight: 3, opacity: 0.9 };
                                    return { color: '#e6550d', weight: 2, fillOpacity: 0.25 };
                                }
                            }).addTo(map);

                            const bounds = (typeof layer.getBounds === 'function') ? layer.getBounds() : null;
                            if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
                                map.fitBounds(bounds, { padding: [20, 20] });
                            }
                        }

                        // Render GeoJSON Points as markers and keep a single draggable representative marker
                        const pointLayer = L.geoJSON(geometry, {
                            pointToLayer: (feature, latlng) => L.marker(latlng)
                        }).addTo(map);

                        // Determine marker position: prefer pointLayer bounds center, fallback to first coord, else model lat/lng
                        let markerPos = null;
                        const pBounds = (typeof pointLayer.getBounds === 'function') ? pointLayer.getBounds() : null;
                        if (pBounds && typeof pBounds.isValid === 'function' && pBounds.isValid()) {
                            markerPos = pBounds.getCenter();
                        } else {
                            const first = findFirstCoord(geometry);
                            if (first && first.length >= 2) {
                                const lng = parseFloat(first[0]);
                                const lat = parseFloat(first[1]);
                                if (!isNaN(lat) && !isNaN(lng)) markerPos = L.latLng(lat, lng);
                            }
                        }

                        if (!markerPos && !isNaN(latModel) && !isNaN(lngModel)) {
                            markerPos = L.latLng(latModel, lngModel);
                        }

                        // Create draggable marker if we have a position
                        if (markerPos) {
                            const repMarker = L.marker(markerPos, { draggable: true }).addTo(map);

                            // Ensure inputs reflect initial marker pos
                            setInputs(markerPos.lat, markerPos.lng);

                            repMarker.on('dragend', function () {
                                const pos = repMarker.getLatLng();
                                setInputs(pos.lat, pos.lng);
                            });

                            map.on('click', function (e) {
                                const pos = e.latlng;
                                repMarker.setLatLng(pos);
                                setInputs(pos.lat, pos.lng);
                            });
                        } else {
                            // If we have no usable geometry and no model coords, let clicks create/update a marker
                            let tempMarker = null;
                            map.on('click', function (e) {
                                const pos = e.latlng;
                                if (!tempMarker) {
                                    tempMarker = L.marker(pos, { draggable: true }).addTo(map);
                                    tempMarker.on('dragend', () => {
                                        const p = tempMarker.getLatLng();
                                        setInputs(p.lat, p.lng);
                                    });
                                } else {
                                    tempMarker.setLatLng(pos);
                                }
                                setInputs(pos.lat, pos.lng);
                            });
                        }
                    } else {
                        // No geometry: fallback to model lat/lng if present — create draggable marker
                        if (!isNaN(latModel) && !isNaN(lngModel)) {
                            const marker = L.marker([latModel, lngModel], { draggable: true }).addTo(map);
                            setInputs(latModel, lngModel);
                            marker.on('dragend', function () {
                                const pos = marker.getLatLng();
                                setInputs(pos.lat, pos.lng);
                            });
                            map.on('click', function (e) {
                                const pos = e.latlng;
                                marker.setLatLng(pos);
                                setInputs(pos.lat, pos.lng);
                            });
                        } else {
                            // No coords available: let clicks create a marker
                            let tempMarker = null;
                            map.on('click', function (e) {
                                const pos = e.latlng;
                                if (!tempMarker) {
                                    tempMarker = L.marker(pos, { draggable: true }).addTo(map);
                                    tempMarker.on('dragend', () => {
                                        const p = tempMarker.getLatLng();
                                        setInputs(p.lat, p.lng);
                                    });
                                } else {
                                    tempMarker.setLatLng(pos);
                                }
                                setInputs(pos.lat, pos.lng);
                            });
                        }
                    }
                } catch (err) {
                    console.warn('Error rendering admin report map', err);
                } finally {
                    setTimeout(() => { try { map.invalidateSize(); } catch (_) { } }, 120);
                }
            })();
        </script>
    }
}
